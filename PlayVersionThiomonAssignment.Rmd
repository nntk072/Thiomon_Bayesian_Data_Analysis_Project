Environment setup

```{r}
rm(list = ls())
setwd("/notebooks/bda2024/Bayes_project")
SEED = 42

if (!require(readr)) {
    install.packages("readr")
    library(readr)
}

if (!require(rstan)) {
    install.packages("rstan")
    library(rstan)
}

if (!require(loo)) {
    install.packages("loo")
    library(loo)
}

if (!require(gridExtra)) {
    install.packages("gridExtra")
    library(gridExtra)
}

if (!require(grid)) {
    install.packages("grid")
    library(grid)
}
if (!require(rmarkdown)) {
    install.packages("rmarkdown")
    library(rmarkdown)
}

if (!require(tidybayes)) {
    install.packages("tidybayes")
    library(tidybayes)
}

if (!require(brms)) {
    install.packages("brms")
    library(brms)
}

if (!require(metadat)) {
  install.packages("metadat")
  library(metadat)
}

if(!require(cmdstanr)){
    install.packages("cmdstanr", repos = c("https://mc-stan.org/r-packages/", getOption("repos")))
    library(cmdstanr)
}

cmdstan_installed <- function(){
  res <- try(out <- cmdstanr::cmdstan_path(), silent = TRUE)
  !inherits(res, "try-error")
}

if(!cmdstan_installed()){
    install_cmdstan()
}

if(!require(ggplot2)){
    install.packages("ggplot2")
    library(ggplot2)
}

ggplot2::theme_set(theme_minimal(base_size = 14))
if(!require(bayesplot)){
    install.packages("bayesplot")
    library(bayesplot)
}

if(!require(posterior)){
    install.packages("posterior")
    library(posterior)
}

if (!require(priorsense)) {
  install.packages("priorsense")
  library(priorsense)
}

if (!require(tibble)) {
  install.packages("tibble")
  library(tibble)
}

if (!require(RColorBrewer)) {
  install.packages("RColorBrewer")
  library(RColorBrewer)
}

if (!require(dplyr)) {
  install.packages("dplyr")
  library(dplyr)
}

if (!require(tinytable)) {
  install.packages("tinytable")
  library(tinytable)
}

if (!require(pROC)) {
  install.packages("pROC")
  library(pROC)
}

if (!require(caret)) {
  install.packages("caret")
  library(caret)
}

if(!require(fitdistrplus)){
    install.packages("fitdistrplus", repos = c("https://mc-stan.org/r-packages/", getOption("repos")))
    library(fitdistrplus)
}

options(tinytable_format_num_fmt = "significant_cell", tinytable_format_digits = 2, tinytable_tt_digits=2)
```

Data setup

```{r}
#Loading the data
load("thiomon.rda")

#Cleanup entries that have NaN values or values that are not populated
thiomon <- na.omit(thiomon)
```

Correlation Matrix for observation between retransmission and the target variable

```{r}
# From the original paper top-7 recommended parameters from CBC
#c("hgb", "lymph_percent", "hct","neut_percent", "plt", "alb", "ast")]

#Process the data set with some additional processing
source_data <- thiomon

# Set the age of the patient, granularity years
source_data["age"] <- round(thiomon$days_of_life / 365, digits = 0)

# Simple predictor check: mean corpuscular volume [MCV] and reductions in the white blood cell count [WBC], MCV/WBC ratio
source_data["mcv_wbc_rat"] <- round(thiomon$mcv / thiomon$wbc, digits = 0)

# The systemic immune-inflammation index (SII), defined as neutrophils Ã— platelets / lymphocytes
source_data["sii_rat"] <- round((source_data$plt * source_data$neut_percent) / source_data$lymph_percent, digits = 0)
source_data["log_siirat"] <- log(source_data["sii_rat"])

#The AST/ALT ratio or De Ritis ratio is the ratio between the concentrations of two enzymes, aspartate transaminase (AST) and alanine transaminase, aka alanine aminotransferase (ALT), in the blood of a human
source_data["deRitisRatio"] <- round(source_data$ast / source_data$alt, digits = 2)

source_data["age_group"] <- floor(source_data["age"]/10) + 1

source_data["hbghctrat"] = round(thiomon$hgb/thiomon$hct,2)

# Group hct into 10 groups, by splitting into 10 ranges (max - min) / 10
#source_data["hbghctrat"] <- cut(source_data$hbghctrat, breaks = seq(min(source_data$hbghctrat), max(source_data$hbghctrat), length.out = 11), labels = c("1", "2", "3", "4", "5", "6", "7", "8", "9", "10"))
source_data["hbghctrat"] <- cut(source_data$hbghctrat, breaks = seq(min(source_data$hbghctrat), max(source_data$hbghctrat), length.out = 6), labels = c("1", "2", "3", "4", "5"))
  
#Split data for model fitting and testing separately
store_data <- source_data[1:4500, ]
test_data <- source_data[4501:nrow(source_data), ]

# Save the data file so we don't have to process everytime
save(store_data, file = "thiomon_source_data.rda")
save(test_data, file = "thiomon_test_data.rda")
```

```{r}
# Sample a subset of the 4500 rows to improve computation time
NUM_OF_SAMPLES <- 2000
sampled_df <- source_data[sample(nrow(source_data), NUM_OF_SAMPLES), ]

# View the sampled data frame if needed
#print(sampled_df, n=20)
```

```{r}
#Purely pooled model
ref_thiomon_formulae_pooled <- bf(remission ~ 1, family = "bernoulli")

thiomon_priors_default_priors_pooled <- get_prior(ref_thiomon_formulae_pooled, data = sampled_df)

thiomon_data_model_pooled <- brm(
    formula = ref_thiomon_formulae_pooled,
    prior = thiomon_priors_default_priors_pooled,
    data = sampled_df,
    save_pars = save_pars(all = TRUE),
    iter = 2000,
    warmup = 1000,
    chains = 4,                           # Number of chains
    control = list(
      adapt_delta = 0.8,                 # Increase acceptance rate target if needed
      max_treedepth = 20                 # Increase the tree depth if needed
    ) 
)
```

`{print(df,nrows=32)}`

Filtering the variables and pre-processing the data

```{r}
#Task 2: Use the top 7 blood parameters and improvise on the model
#BRMS formula using the top 7
#thiomon_formulae_3 <- bf(remission ~ 0 + hgb + lymph_percent + hct + neut_percent + plt + alb + ast, family = "bernoulli")

#One improvement is to combine the different blood parameters according to medical science. SII and deRitisRatio are 2 such covariates which are recogonized. Reducing the number of covariates not only is computationally efficient but the search for informative priors is easier
#ref_thiomon_formulae <- bf(remission ~ 0 + hgb + log_siirat + hct + deRitisRatio, family = "bernoulli")

#ref_thiomon_formulae <- bf(remission ~ 0  + lymph_percent + hct + neut_percent + plt + alb + ast + alk + mono_percent + rdw + mch + wbc + hgb + age + mcv + eos_percent + alt + mpv + baso_percent + gluc + mchc + tbil + cal + prot + un + pot + chlor + co2 + sod + creat, family = "bernoulli")

#thiomon_formulae_3 <- bf(remission ~ 0 + hgb + lymph_percent + hct + neut_percent + plt + alb + ast, family = "bernoulli")

#Default priors are flat and created at least two issues
#Issue 1 - Accuracy of the model is not optimal (61%)
#Issue 2 - Prior sensitivity checks fail as flat priors have infinite k-hat values
#There was no issue with improper posterior with flat priors

ref_thiomon_formulae_separate <- bf(remission ~ 0 + hgb + hct, family = "bernoulli")

thiomon_priors_default_priors_separate <- get_prior(ref_thiomon_formulae_separate, data = sampled_df)

#Values of the parameters and their legal values were checked and also tools like fitdist were used

#Normal distribution works well for all parameters except SII wherein instead of SII, log(SII) is uniformly distributed
#Informative priors are set based on the distributions of the parameters themselves after plotting with e.g., mcmc_hist()

#All parameters of model saved for e.g., for LOO and moment matching if needed

(thiomon_set_priors_informative_separate <- c(
  prior(
    normal(13,5),
    class = "b",
    coef = "hgb"
  ),

  prior(
    normal(35,5),
    class = "b",
    coef = "hct"
  ) 
))

thiomon_data_model_separate <- brm(
    formula = ref_thiomon_formulae_separate,
    prior = thiomon_priors_default_priors_separate,
    data = sampled_df,
    iter = 2000,
    warmup = 1000,
    chains = 4,                           # Number of chains
    control = list(
      adapt_delta = 0.8,                 # Increase acceptance rate target if needed
      max_treedepth = 20                 # Increase the tree depth if needed
    ) 
)
```

Process the data

```{r}
ref_thiomon_formulae_hier <- bf(remission ~ 0 + hgb + hct + (1 | hbghctrat), family = "bernoulli")

thiomon_priors_default_priors_hier <- get_prior(ref_thiomon_formulae_hier, data = sampled_df)

(thiomon_set_priors_informative_hier <- c(
  prior(
    normal(13,5),
    class = "b",
    coef = "hgb"
  ),
  
  prior(
    normal(35,5),
    class = "b",
    coef = "hct"
  ) 
))

thiomon_data_model_hier <- brm(
    formula = ref_thiomon_formulae_hier,
    prior = thiomon_priors_default_priors_hier,
    data = sampled_df,
    iter = 2000,
    warmup = 1000,
    chains = 4,                           # Number of chains
    control = list(
      adapt_delta = 0.8,                 # Increase acceptance rate target if needed
      max_treedepth = 20                 # Increase the tree depth if needed
    )
)
```

```{r}
loo_compare(loo(thiomon_data_model_pooled), loo(thiomon_data_model_separate), loo(thiomon_data_model_hier)) |>
  as.data.frame() |>
  rownames_to_column("model") |>
  select(elpd_diff, se_diff) |>
  tt()
```

```{r}
if (!require(patchwork)) {
  install.packages("patchwork")
  library(patchwork)
}

#model_draws <- as_draws_df(thiomon_data_model_hier)
ph <- thiomon_data_model_hier |>
  spread_rvars(b_hgb, b_hct, r_hbghctrat[hbghctrat,]) |>
  mutate(mean_value = b_hgb + b_hct + r_hbghctrat) |>
  ggplot(aes(xdist= 1/(1+exp(-mean_value)), y=hbghctrat)) +
  stat_halfeye() +
  scale_y_continuous(breaks=1:5) +
  labs(x='Remission ratio', y='Ratio', title='Hierarchical')

ps <- thiomon_data_model_separate |>
  spread_rvars(b_hgb, b_hct) |>
  mutate(mean_value = b_hgb + b_hct) |>
  ggplot(aes(xdist=1/(1+exp(-mean_value)), y=0)) +
  stat_halfeye() +
  scale_y_continuous(breaks=NULL) +
  labs(x='Remission ratio', y='Across all', title='Separate model')

pp <- thiomon_data_model_pooled |>
  spread_rvars(b_Intercept) |>
  mutate(mean_value = b_Intercept) |>
  ggplot(aes(xdist=1/(1+exp(-mean_value)), y=0)) +
  stat_halfeye() +
  scale_y_continuous(breaks=NULL) +
  labs(x='Remission ratio', y='Across all', title='Pooled model')


(ph / ps / pp) * xlim(c(0.0,1.0))
```

```{r}
#Task 0 - Inapplicability of pooled model
#Why pooled model cannot be used here? With pooled model there is one single global intercept which from the practical point does not make sense as there is no way in which any blood parameter can take the value 0 in real life for humans. We can only experiment with separate models.

#Continue investigations with separate model
#Task 1: Testing the predictive power of a bayesian model using all the parameters indicated in the research paper
#The baseline formula uses 100% of the blood parameters
#thiomon_baseline <- bf(remission ~ 0 + hgb + lymph_percent + hct + neut_percent + plt + alb + ast + alk + mono_percent + rdw + mch + wbc + age + mcv + eos_percent + alt + mpv + baso_percent + gluc + mchc + tbil + cal + prot + un + pot + chlor + co2 + sod + creat, family = "bernoulli")

#The priors are default ones
#thiomon_priors <- get_prior(thiomon_formulae, data = sampled_df)

#Purpose of Task 1 is to numerically assess the predictive power of the baseline bayesian model fitting all blood parameters to a bionomial distribution with logit as the outcome to predict the remission status of the disease
#The model predicts with 66% accuracy (79% in the paper with a machine learning model)
#For future work section
#Improve the accuracy of the model by using informative priors,combine

#Use model for inference, test samples were not used in the model generation
TEST_SAMPLES = 559
test_df <- source_data[sample(nrow(source_data), TEST_SAMPLES), ]

# View the sampled data frame
#print(test_df)

# Predict probabilities on the test data
predicted_probs <- posterior_predict(thiomon_data_model_hier, 
                                     newdata = test_df, draws = 4000)

# Calculate the mean predicted probabilities for each test sample
mean_probs <- colMeans(predicted_probs)

# Generate ROC curve
roc_curve <- roc(test_df$remission, mean_probs)
plot(roc_curve, main = "ROC Curve")

# Predict classes based on a threshold of 0.5
predicted_classes <- ifelse(mean_probs >= 0.5, 1, 0)

# Generate confusion matrix
conf_matrix <- confusionMatrix(as.factor(predicted_classes), as.factor(test_df$remission))

#Convert this to data frame and use tt() for pretty print
print(conf_matrix)
```

thiomon_data_model \<- brm(

formula = ref_thiomon_formulae,

prior = thiomon_priors_default_priors,

data = source_data,

save_pars = save_pars(all = TRUE),

iter = 2000,

warmup = 1000,

chains = 4, \# Number of chains

control = list(

adapt_delta = 0.8, \# Increase acceptance rate target if needed

max_treedepth = 20 \# Increase the tree depth if needed

)

)

thiomon_data_model \<- brm(

formula = thiomon_formulae,

prior = thiomon_priors,

data = sampled_df,

save_pars = save_pars(all = TRUE),

iter = 2000,

warmup = 1000,

chains = 4, \# Number of chains

control = list(

adapt_delta = 0.8, \# Increase acceptance rate target

max_treedepth = 20 \# Increase the tree depth
